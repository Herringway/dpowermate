module powermate;

import std.stdio, std.conv, std.string, std.algorithm, std.exception;

version(linux) {
	import core.sys.posix.sys.ioctl;
	import core.sys.posix.sys.time;
	import core.stdc.config;
	c_ulong EVIOCGNAME(T)() {
		return cast(c_ulong)_IOC!(T)(_IOC_READ, 'E', 6);
	}
	static ushort EV_SYN = 0; // Synchronization events
	static ushort EV_KEY = 1; // Button push events
	static ushort EV_REL = 2; // Relative axis change events
	static ushort EV_MSC = 4; // Misc events

	static ushort SYN_REPORT = 0; // Reports

	static ushort BTN_MISC = 0x100; // Miscellaneous button pushes

	static ushort REL_DIAL = 7; // Dial rotated

	static ushort MSC_PULSELED = 1; // Pulse an LED
	struct input_event {
		timeval time;
		ushort type;
		ushort code;
		int value;
	}
}
/**
 * Unofficial Griffin PowerMate library for D.
 * Authors: Cameron "Herringway" Ross
 * Bugs: Only functions on linux
 * Examples: 
 * --------------------
 * auto powermate = new PowerMate("/dev/input/event0"); //Open PowerMate device with read and write access
 * auto powermate = new PowerMate(File("/dev/input/event0", "r")); //read-only access, only event handlers will be available
 * powermate.Brightness = 0xFF; //Set brightness to maximum
 * powermate.PulseSpeed = 0xFF; //Set pulse speed to maximum
 * powermate.PulseTable = 1; //Use alternate pulse style
 * powermate.PulseStyle = PowerMate.PulseStyles.STYLE2; //Same as above
 * powermate.PulseAsleep = true; //Pulse when PC is asleep
 * powermate.PulseAwake = false; //Do not pulse when PC is awake
 * powermate.update(); //Sets LED parameters
 * powermate.registerEventHandler((x) => writeln(x), PowerMate.Event.BUTTONDOWN); //Register a button push event handler: writes to stdout when button is pushed
 * powermate.readNextEvent(); //Wait until an input event occurs, then execute associated event handlers
 * powermate.readEvents(); //Read events & execute event handlers until thread is destroyed
 * --------------------
 * Throws: FileException on I/O errors
 */
class PowerMate {
	public {
		ubyte Brightness = 0x80; ///LED Brightness for the PowerMate device. Will not reflect current brightness until device has been updated at least once.
		ushort PulseSpeed = 255; ///Pulse speed for the PowerMate device. Will not reflect current pulse speed until device has been updated at least once.
		PulseStyles PulseStyle; ///Pulse style in use for the PowerMate device. Will not reflect current pulse style until device has been updated at least once.
		bool PulseAsleep = false; ///Whether or not the PowerMate device will pulse while PC is asleep.
		bool PulseAwake = true; ///Whether or not the PowerMate device will pulse while PC is awake.
		enum PulseStyles : ubyte { STYLE1, STYLE2, STYLE3 }; ///Pulse styles available
		enum Event { ALL, BUTTONDOWN, BUTTONUP, CLOCKWISE, COUNTERCLOCKWISE }; ///Events generated by device
		
		/**
		 * Provides compatibility with older code. Do not use.
		 */
		deprecated {
			@property ubyte PulseTable() {
				return cast(ubyte)PulseTable;
			}
			@property ubyte PulseTable(ubyte table) {
				return cast(ubyte)(PulseTable = cast(PulseStyles)table);
			}
		}
	}
	
	private {
		File handle; ///Internal file handle for accessing the device
		void delegate(Event event)[][Event] eventHandlers; ///Event handlers for various events
	}
	invariant() {
		enforce(PulseStyle < 3, "Invalid pulse style specified");
		enforce(PulseSpeed < 511, "Pulse Speed too high!");
	}
	this(File input) {
		handle = input;
	}
	this(string filename) {
		handle = File(filename, "r+");
	}
	/**
	 * Registers an event handler that will be executed when its specified event occurs.
	 * Params:
	 *   eventHandler = the function to be executed
	 *   event = the event for which the function will be executed
	 */
	void registerEventHandler(void delegate(Event event) eventHandler, Event event = Event.ALL) {
		import std.traits;
		if (event != Event.ALL)
			eventHandlers[event] ~= eventHandler;
		else {
			foreach (iEvent; [EnumMembers!Event])
				if (iEvent != Event.ALL)
					eventHandlers[iEvent] ~= eventHandler;
		}
	}
	///ditto
	void registerEventHandler(void function(Event event) eventHandler, Event event = Event.ALL) {
		import std.functional;
		registerEventHandler(toDelegate(eventHandler), event);
	}
	/**
	 * Waits & executes functions for events forever, until thread is killed, or until the device stops being valid; whichever occurs first.
	 * Throws: FileException on I/O error, usually if device becomes inaccessible
	 */
	void readEvents() {
		while (true)
			readNextEvent();
	}
	/**
	 * Waits & executes functions for one event.
	 * Throws: FileException on I/O error, usually if device becomes inaccessible
	 */
	void readNextEvent() {
		version(linux) {
			input_event[1] t;
			while (true) {
				handle.rawRead(t);
				Event event;
				if ((t[0].type == EV_KEY) && (t[0].code == BTN_MISC)) {
					if (t[0].value == 1)
						event = Event.BUTTONDOWN;
					else if (t[0].value == 0)
						event = Event.BUTTONUP;
				}
				else if ((t[0].type == EV_REL) && (t[0].code == REL_DIAL)) {
					if (t[0].value >= 1)
						event = Event.CLOCKWISE;
					else if (t[0].value <= -1)
						event = Event.COUNTERCLOCKWISE;
				}
				else if ((t[0].type == EV_SYN) && (t[0].code == SYN_REPORT)) {
					break;
				}
				else {
					debug writeln("Unhandled: ", t[0]);
					continue;
				}
				foreach (handler; eventHandlers[event])
					handler(event);
			}
		}
	}
	/**
	 * Updates LED parameters on device.
	 * Throws: FileException if unable to write to device for some reason.
	 */
	public void update() {
		version(linux) {
			input_event t;
			t.type = EV_MSC;
			t.code = MSC_PULSELED;
			t.value = Brightness | (PulseSpeed << 8) | (PulseStyle << 17) | (PulseAsleep << 19) | (PulseAwake << 20);
			debug writefln("Brightness: %d\nPulse Speed: %d\nPulse Style: %s\nPulse Asleep: %s\nPulse Awake: %s", Brightness, PulseSpeed, PulseStyle, PulseAsleep, PulseAwake);
			handle.rawWrite([t]);
		}
	}
}
/**
 * Determines if file is a PowerMate device connected to the system.
 * Returns: true if file is a PowerMate device, false otherwise.
 * Bugs: Only functions on linux
 */
@property bool isPowerMate(File inFile) {
	version(linux) {
		import core.sys.posix.sys.ioctl, core.sys.linux.errno;
		char[255] name;
		if (ioctl(inFile.fileno(), EVIOCGNAME!(typeof(name)), &name) < 0) {
			debug writefln("Error reading name: %d", errno);
			return false;
		}
		string fixedName = name[0..countUntil(to!string(name), "\0")].idup;
		debug writefln("Found device: %s", fixedName);
		if (fixedName == "Griffin PowerMate")
			return true;
	}
	return false;
}
///ditto
@property bool isPowerMate(string filename) {
	return File(filename, "r").isPowerMate;
}
/**
 * Attempts to find a Griffin PowerMate connected to this system.
 * Returns: The first PowerMate found on the system.
 * Bugs: Only functions on linux
 */
PowerMate findPowerMate() {
	version(linux) {
		import core.sys.posix.sys.ioctl;
		import std.file;
		static final string EventDir = "/dev/input"; //directory containing input event devices
		static final string EventGlob = "event*"; //wildcard to match event devices in directory only
		bool couldNotOpen = false;
		foreach (string eventfile; dirEntries(EventDir, EventGlob, SpanMode.shallow)) {
			debug writefln("Found event file: %s", eventfile);
			try {
				File testFile = File(eventfile, "r+");
				if (testFile.isPowerMate)
					return new PowerMate(testFile);
			} catch (ErrnoException e) {
				couldNotOpen = true;
			}
		}
		if (couldNotOpen)
			throw new Exception("Could not open some event files");
	}
	throw new NoPowerMateException();
}

class NoPowerMateException : Exception {
	this() { super("Powermate not found"); }
}

unittest {
	int clicks = 0;
	int unclicks = 0;
	int clockwiseturns = 0;
	int counterclockwiseturns = 0;
	void testHandler(PowerMate.Event event) {
		if (event == PowerMate.Event.BUTTONDOWN)
			clicks++;
		else if (event == PowerMate.Event.BUTTONUP)
			unclicks++;
		else if (event == PowerMate.Event.CLOCKWISE)
			clockwiseturns++;
		else if (event == PowerMate.Event.COUNTERCLOCKWISE)
			counterclockwiseturns++;
	}
	version(linux) {
		import std.file;
		//Cleanup whether successful or failure
		scope(exit) if (exists("testEventData")) remove("testEventData");
		scope(exit) if (exists("testOutput")) remove("testOutput");
		
		//Test event data reading
		auto t1file = File("testEventData", "w+");
		auto tmpStruct = [input_event(),input_event()];
		tmpStruct[0].type = EV_KEY; tmpStruct[0].code = BTN_MISC; tmpStruct[0].value = 1;
		tmpStruct[1].type = EV_SYN; tmpStruct[1].code = SYN_REPORT;
		t1file.rawWrite(tmpStruct);
		tmpStruct[0].type = EV_KEY; tmpStruct[0].code = BTN_MISC; tmpStruct[0].value = 0;
		tmpStruct[1].type = EV_SYN; tmpStruct[1].code = SYN_REPORT;
		t1file.rawWrite(tmpStruct);
		tmpStruct[0].type = EV_REL; tmpStruct[0].code = REL_DIAL; tmpStruct[0].value = 1;
		tmpStruct[1].type = EV_SYN; tmpStruct[1].code = SYN_REPORT;
		t1file.rawWrite(tmpStruct);
		tmpStruct[0].type = EV_REL; tmpStruct[0].code = REL_DIAL; tmpStruct[0].value = -1;
		tmpStruct[1].type = EV_SYN; tmpStruct[1].code = SYN_REPORT;
		t1file.rawWrite(tmpStruct);
		t1file.close();
		auto powermate = new PowerMate(File("testEventData", "r"));
		powermate.registerEventHandler(&testHandler);
		foreach (i; 0..4)
			powermate.readNextEvent();
		assert(clicks == 1, "Clicks mismatch");
		assert(unclicks == 1, "Click releases mismatch");
		assert(clockwiseturns == 1, "Clockwise Turns mismatch");
		assert(counterclockwiseturns == 1, "Counterclockwise Turns mismatch");
		
		//Test LED update output
		auto t2file = File("testOutput", "w+");
		auto powermate2 = new PowerMate(t2file);
		powermate2.Brightness = 127;
		powermate2.PulseSpeed = 255;
		powermate2.PulseStyle = PowerMate.PulseStyles.STYLE2;
		powermate2.PulseAwake = true;
		powermate2.PulseAsleep = true;
		powermate2.update();
		union input_test { input_event a; ubyte[a.sizeof] b; }
		ubyte[input_test.a.sizeof] buffer;
		t2file.seek(0);
		t2file.rawRead(buffer);
		static input_test test = {a: input_event(timeval(), 0x0004, 0x0001, 0x001AFF7F)}; //Output should equal this on all platforms
		assert(buffer == test.b, "Bad output from LED update");
	}
}

